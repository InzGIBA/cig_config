# CIGG Config Tool — README

Этот репозиторий содержит минимальный набор утилит для разборки/сборки конфигов формата **XOR-XML + “CIGG” footer (32B)**.

---

## Что это за формат

Файл состоит из двух частей:

```
+---------------------+-----------------------+
|  payload_enc (N B)  |   CIGG footer (32 B)  |
+---------------------+-----------------------+
                        ^ не шифруется
```

* **payload\_enc** — это расшифрованный XML, **побайтово XOR**’нутый ключом `0xAA`.
* **footer** — последние 32 байта, **не** зашифрованы.

### Структура footer (CIGG)

Offsets и значения (смещения указаны в байтах от начала хвоста):

```
00..03  'C' 'I' 'G' 'G'                # сигнатура
04..05  00 00                          # константа
06..07  payload_len_be                 # длина payload_enc (2 байта, big-endian)
08..11  crc32_bzip2_be(payload_enc)    # CRC-32/BZIP2 по payload_enc, big-endian
12..15  11 11 11 11                    # константа
16..31  00 ... 00                      # паддинг (16 байт)
```

Где:

* `payload_len_be = len(payload_enc) & 0xFFFF` (фирмварь хранит длину в 16 битах).
* `CRC-32/BZIP2` — это “неотражённый” вариант (poly `0x04C11DB7`, init `0xFFFFFFFF`, refin=`False`, refout=`False`, xorout=`0xFFFFFFFF`).

    **Важно:** CRC считается **от зашифрованного** payload (`payload_enc`) и пишется **big-endian**.

### Нюанс с концом файла

Перед `CIGG` обычно есть **один** завершающий перевод строки в расшифровке (`>\n`).
Если его нет — собирать можно и без него, но некоторые устройства ожидают этот байт.
В скрипте сборки это управляется опцией `--lf` (добавить один `\n`, если его нет).

---

## Скрипты

### `cig_config.py` — основной

* `decrypt` — извлекает XML из `config.dat`. Ключ XOR авто-детектится (по умолчанию `0xAA`).
* `encrypt` — шифрует XML XOR’ом, рассчитывает `len` и `CRC-32/BZIP2` по `payload_enc`, формирует валидный `CIGG`-хвост. **Никаких мета-файлов.**

---

## Быстрый старт

### 1) Расшифровка (получить XML)

```bash
python cig_config.py decrypt config.dat
# → config_decrypted.xml
```

Пример вывода:

```
OK: XML → config_decrypted.xml
ℹ XOR key=0xaa  payload_len(enc)=39195 (footer says 39195)
ℹ footer CRC32/BZIP2=50480570  our CRC would be 50480570
```

### 2) Сборка изменённого XML

Отредактируйте `config_decrypted.xml` и соберите:

```bash
python cig_config.py encrypt config_decrypted.xml --lf -o new.dat
```

* `--lf` добавит **ровно один `\n`** в конец XML (если его не было).
* `-o` задаёт имя выходного файла.

Проверка хвоста:

```bash
tail -c 40 new.dat | xxd -g1
# Должно быть:
# .. .. 43 49 47 47 00 00  <lenBE>  <crcBE>  11 11 11 11  00..00
```

---

## Проверка/Верификация

1. **Длина.**
   Последние 32 байта: позиции `[06..07]` = `len(payload_enc)` в big-endian.
   Сверить можно так:

   ```bash
   stat -c%s new.dat         # общий размер
   # payload_len = size - 32
   ```

2. **CRC-32/BZIP2.**
   Должны совпадать с байтами `[08..11]` (big-endian). Скрипт печатает расчёт при `decrypt`.

3. **Байт перед CIGG.**
   В расшифровке обычно `0x0A` (`\n`). Если нужен строго один — используйте `--lf`.

---

## Примеры

Оригинал (из отчёта):

```
footer: 43 49 47 47  00 00  99 1b  50 48 05 70  11 11 11 11  00..00
                      ^^^^^  ^^^^^^^^^^
                      len    CRC32/BZIP2
```

* `0x991b` = **39195** — длина `payload_enc`.
* CRC-32/BZIP2(payload\_enc) = `0x50480570` → байты `50 48 05 70`.

---

## Под капотом (алгоритмы)

* **XOR:** `payload_enc = xml_dec ^ 0xAA` (побайтово).
  Автодетект при `decrypt` пытается подобрать ключ по эвристике (`?>`, `</…>`, печатность и т. п.).

* **CRC-32/BZIP2 (неотражённый):**

  ```
  init = 0xFFFFFFFF
  for byte in data:
      idx = ((crc >> 24) ^ byte) & 0xFF
      crc = table[idx] ^ ((crc << 8) & 0xFFFFFFFF)
  crc ^= 0xFFFFFFFF
  # write big-endian
  ```

* **Footer assemble:**

  ```
  lenBE = uint16_be(len(payload_enc))
  crcBE = crc32_bzip2_be(payload_enc)
  footer = b"CIGG" + b"\x00\x00" + lenBE + crcBE + b"\x11\x11\x11\x11" + b"\x00"*16
  ```

---

## Частые проблемы и решения

* **“Пропал 1 байт перед CIGG”.**
  Это завершающий `\n`. Собирайте с `--lf`, чтобы гарантировать один перевод строки.

* **CRC/длина не совпадают.**
  Убедитесь, что считаете **по зашифрованному** payload и используете **big-endian** запись полей.
  Пересоберите через `encrypt` — скрипт делает всё автоматически.

* **XML “ломается” после правок.**
  Следите за кодировкой (UTF-8 без BOM), не меняйте лишние переводы строк в середине файла и не вставляйте NUL.

* **Нет `CIGG` в конце.**
  Некоторые образы идут без хвоста — в этом случае `decrypt` просто снимет XOR с всего файла, а `encrypt` соберёт `payload_enc` **без** хвоста (если так нужно вашей модели).

---

## FAQ

**Почему длина — 2 байта? Что при > 65535?**
Так устроен формат конкретной прошивки. Скрипт записывает `len(payload_enc) & 0xFFFF`. На практике размеры в этот диапазон укладываются.

**Почему CRC считается от шифротекста, а не от XML?**
Так реализована проверка у устройства: CRC32/BZIP2 берётся **по `payload_enc`** (после XOR).

**Можно ли менять XOR-ключ?**
В коде по умолчанию `0xAA`. При `decrypt` ключ autodetect; при `encrypt` — фиксированный (`0xAA`). Если у вашей модели другой, замените константу в скрипте.

---

## Лицензия

Использование на свой риск. Скрипт дан “как есть” для инженерного анализа и обслуживания собственных устройств/конфигураций.

---

## Короткая памятка команд

```bash
# Расшифровать:
python cig_config.py decrypt config.dat

# Собрать (добавить один '\n' если его нет) → new.dat:
python cig_config.py encrypt config_decrypted.xml --lf -o new.dat

# Проверить хвост:
tail -c 40 new.dat | xxd -g1
```

Если вдруг ваше устройство отличается (нестандартный хвост или другой ключ) — напишите, добавим опции под ваш вариант.
